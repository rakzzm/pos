"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/staff/page",{

/***/ "(app-pages-browser)/./src/stores/staffStore.ts":
/*!**********************************!*\
  !*** ./src/stores/staffStore.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStaffStore: () => (/* binding */ useStaffStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n\nconst useStaffStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)((set, get)=>({\n        staff: [],\n        leaveRequests: [],\n        payrollRecords: [],\n        loading: false,\n        error: null,\n        fetchStaff: async ()=>{\n            set({\n                loading: true,\n                error: null\n            });\n            try {\n                const response = await fetch('/api/staff');\n                if (!response.ok) throw new Error('Failed to fetch staff');\n                const data = await response.json();\n                const mappedStaff = data.map((s)=>({\n                        id: s.id,\n                        employeeId: s.employeeId,\n                        name: s.name,\n                        email: s.email,\n                        phone: s.phone,\n                        position: s.position,\n                        department: s.department,\n                        hireDate: new Date(s.hireDate).toISOString().split('T')[0],\n                        salary: s.salary,\n                        status: s.status,\n                        leaveBalance: {\n                            annual: s.leaveBalanceAnnual,\n                            sick: s.leaveBalanceSick,\n                            personal: s.leaveBalancePersonal\n                        },\n                        performance: {\n                            rating: s.performanceRating,\n                            lastReview: s.lastReview ? new Date(s.lastReview).toISOString().split('T')[0] : ''\n                        }\n                    }));\n                // Extract leave requests\n                const allLeaveRequests = [];\n                data.forEach((s)=>{\n                    if (s.leaveRequests && Array.isArray(s.leaveRequests)) {\n                        s.leaveRequests.forEach((lr)=>{\n                            // ... existing mapping logic or improved\n                            allLeaveRequests.push({\n                                id: lr.id,\n                                staffId: s.id,\n                                staffName: s.name,\n                                type: lr.type,\n                                startDate: new Date(lr.startDate).toISOString().split('T')[0],\n                                endDate: new Date(lr.endDate).toISOString().split('T')[0],\n                                days: Math.ceil((new Date(lr.endDate).getTime() - new Date(lr.startDate).getTime()) / (1000 * 60 * 60 * 24)) + 1,\n                                reason: lr.reason,\n                                status: lr.status,\n                                appliedDate: new Date(lr.appliedDate).toISOString().split('T')[0]\n                            });\n                        });\n                    }\n                });\n                set({\n                    staff: mappedStaff,\n                    leaveRequests: allLeaveRequests\n                });\n            } catch (error) {\n                set({\n                    error: error.message\n                });\n            } finally{\n                set({\n                    loading: false\n                });\n            }\n        },\n        addStaff: async (staffData)=>{\n            set({\n                loading: true,\n                error: null\n            });\n            try {\n                const response = await fetch('/api/staff', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify(staffData)\n                });\n                if (!response.ok) throw new Error('Failed to create staff');\n                await get().fetchStaff();\n            } catch (error) {\n                set({\n                    error: error.message\n                });\n            } finally{\n                set({\n                    loading: false\n                });\n            }\n        },\n        updateStaff: async (id, staffData)=>{\n            set({\n                loading: true,\n                error: null\n            });\n            try {\n                // Flatten for API\n                const payload = {\n                    ...staffData\n                };\n                if (staffData.leaveBalance) {\n                    payload.leaveBalance = {\n                        ...staffData.leaveBalance\n                    };\n                }\n                const response = await fetch(\"/api/staff/\".concat(id), {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify(payload)\n                });\n                if (!response.ok) throw new Error('Failed to update staff');\n                await get().fetchStaff();\n            } catch (error) {\n                set({\n                    error: error.message\n                });\n            } finally{\n                set({\n                    loading: false\n                });\n            }\n        },\n        deleteStaff: async (id)=>{\n            set({\n                loading: true,\n                error: null\n            });\n            try {\n                const response = await fetch(\"/api/staff/\".concat(id), {\n                    method: 'DELETE'\n                });\n                if (!response.ok) throw new Error('Failed to delete staff');\n                set((state)=>({\n                        staff: state.staff.filter((m)=>m.id !== id)\n                    }));\n            } catch (error) {\n                set({\n                    error: error.message\n                });\n            } finally{\n                set({\n                    loading: false\n                });\n            }\n        },\n        updateLeaveRequest: async (id, updates)=>{\n            // Existing logic... kept simple\n            set({\n                loading: true\n            });\n            try {\n                await fetch(\"/api/leave-requests/\".concat(id), {\n                    method: 'PUT',\n                    body: JSON.stringify(updates),\n                    headers: {\n                        'Content-Type': 'application/json'\n                    }\n                });\n                await get().fetchStaff();\n            } catch (e) {\n                console.error(e);\n            } finally{\n                set({\n                    loading: false\n                });\n            }\n        },\n        fetchPayroll: async ()=>{\n            set({\n                loading: true,\n                error: null\n            });\n            try {\n                const response = await fetch('/api/payroll');\n                if (!response.ok) throw new Error('Failed to fetch payroll');\n                const data = await response.json();\n                const mappedPayroll = data.map((p)=>({\n                        ...p,\n                        payPeriodStart: new Date(p.payPeriodStart).toISOString().split('T')[0],\n                        payPeriodEnd: new Date(p.payPeriodEnd).toISOString().split('T')[0],\n                        payDate: new Date(p.payDate).toISOString().split('T')[0]\n                    }));\n                set({\n                    payrollRecords: mappedPayroll\n                });\n            } catch (error) {\n                set({\n                    error: error.message\n                });\n            } finally{\n                set({\n                    loading: false\n                });\n            }\n        },\n        runPayroll: async (staffId, periodStart, periodEnd, bonuses, deductions)=>{\n            set({\n                loading: true,\n                error: null\n            });\n            try {\n                const response = await fetch('/api/payroll', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        staffId,\n                        periodStart,\n                        periodEnd,\n                        bonuses,\n                        deductions\n                    })\n                });\n                if (!response.ok) throw new Error('Failed to run payroll');\n                await get().fetchPayroll();\n            } catch (error) {\n                set({\n                    error: error.message\n                });\n                throw error;\n            } finally{\n                set({\n                    loading: false\n                });\n            }\n        },\n        markPayrollPaid: async (id, paymentMethod)=>{\n            set({\n                loading: true,\n                error: null\n            });\n            try {\n                const response = await fetch(\"/api/payroll/\".concat(id), {\n                    method: 'PUT',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        status: 'paid',\n                        paymentMethod\n                    })\n                });\n                if (!response.ok) throw new Error('Failed to update payroll');\n                await get().fetchPayroll();\n            } catch (error) {\n                set({\n                    error: error.message\n                });\n            } finally{\n                set({\n                    loading: false\n                });\n            }\n        }\n    }));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZXMvc3RhZmZTdG9yZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpQztBQXlFMUIsTUFBTUMsZ0JBQWdCRCwrQ0FBTUEsQ0FBYSxDQUFDRSxLQUFLQyxNQUFTO1FBQzdEQyxPQUFPLEVBQUU7UUFDVEMsZUFBZSxFQUFFO1FBQ2pCQyxnQkFBZ0IsRUFBRTtRQUNsQkMsU0FBUztRQUNUQyxPQUFPO1FBRVBDLFlBQVk7WUFDVlAsSUFBSTtnQkFBRUssU0FBUztnQkFBTUMsT0FBTztZQUFLO1lBQ2pDLElBQUk7Z0JBQ0YsTUFBTUUsV0FBVyxNQUFNQyxNQUFNO2dCQUM3QixJQUFJLENBQUNELFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU07Z0JBQ2xDLE1BQU1DLE9BQU8sTUFBTUosU0FBU0ssSUFBSTtnQkFFaEMsTUFBTUMsY0FBNkJGLEtBQUtHLEdBQUcsQ0FBQyxDQUFDQyxJQUFZO3dCQUN2REMsSUFBSUQsRUFBRUMsRUFBRTt3QkFDUkMsWUFBWUYsRUFBRUUsVUFBVTt3QkFDeEJDLE1BQU1ILEVBQUVHLElBQUk7d0JBQ1pDLE9BQU9KLEVBQUVJLEtBQUs7d0JBQ2RDLE9BQU9MLEVBQUVLLEtBQUs7d0JBQ2RDLFVBQVVOLEVBQUVNLFFBQVE7d0JBQ3BCQyxZQUFZUCxFQUFFTyxVQUFVO3dCQUN4QkMsVUFBVSxJQUFJQyxLQUFLVCxFQUFFUSxRQUFRLEVBQUVFLFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO3dCQUMxREMsUUFBUVosRUFBRVksTUFBTTt3QkFDaEJDLFFBQVFiLEVBQUVhLE1BQU07d0JBQ2hCQyxjQUFjOzRCQUNaQyxRQUFRZixFQUFFZ0Isa0JBQWtCOzRCQUM1QkMsTUFBTWpCLEVBQUVrQixnQkFBZ0I7NEJBQ3hCQyxVQUFVbkIsRUFBRW9CLG9CQUFvQjt3QkFDbEM7d0JBQ0FDLGFBQWE7NEJBQ1hDLFFBQVF0QixFQUFFdUIsaUJBQWlCOzRCQUMzQkMsWUFBWXhCLEVBQUV3QixVQUFVLEdBQUcsSUFBSWYsS0FBS1QsRUFBRXdCLFVBQVUsRUFBRWQsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRzt3QkFDbEY7b0JBQ0Y7Z0JBRUEseUJBQXlCO2dCQUN6QixNQUFNYyxtQkFBbUMsRUFBRTtnQkFDM0M3QixLQUFLOEIsT0FBTyxDQUFDLENBQUMxQjtvQkFDWixJQUFJQSxFQUFFYixhQUFhLElBQUl3QyxNQUFNQyxPQUFPLENBQUM1QixFQUFFYixhQUFhLEdBQUc7d0JBQ3JEYSxFQUFFYixhQUFhLENBQUN1QyxPQUFPLENBQUMsQ0FBQ0c7NEJBQ3RCLHlDQUF5Qzs0QkFDekNKLGlCQUFpQkssSUFBSSxDQUFDO2dDQUNwQjdCLElBQUk0QixHQUFHNUIsRUFBRTtnQ0FDVDhCLFNBQVMvQixFQUFFQyxFQUFFO2dDQUNiK0IsV0FBV2hDLEVBQUVHLElBQUk7Z0NBQ2pCOEIsTUFBTUosR0FBR0ksSUFBSTtnQ0FDYkMsV0FBVyxJQUFJekIsS0FBS29CLEdBQUdLLFNBQVMsRUFBRXhCLFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dDQUM3RHdCLFNBQVMsSUFBSTFCLEtBQUtvQixHQUFHTSxPQUFPLEVBQUV6QixXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtnQ0FDekR5QixNQUFNQyxLQUFLQyxJQUFJLENBQUMsQ0FBQyxJQUFJN0IsS0FBS29CLEdBQUdNLE9BQU8sRUFBRUksT0FBTyxLQUFLLElBQUk5QixLQUFLb0IsR0FBR0ssU0FBUyxFQUFFSyxPQUFPLEVBQUMsSUFBTSxRQUFPLEtBQUssS0FBSyxFQUFDLEtBQU07Z0NBQy9HQyxRQUFRWCxHQUFHVyxNQUFNO2dDQUNqQjNCLFFBQVFnQixHQUFHaEIsTUFBTTtnQ0FDakI0QixhQUFhLElBQUloQyxLQUFLb0IsR0FBR1ksV0FBVyxFQUFFL0IsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7NEJBQ25FO3dCQUNIO29CQUNGO2dCQUNGO2dCQUVBM0IsSUFBSTtvQkFBRUUsT0FBT1k7b0JBQWFYLGVBQWVzQztnQkFBaUI7WUFDNUQsRUFBRSxPQUFPbkMsT0FBTztnQkFDZE4sSUFBSTtvQkFBRU0sT0FBTyxNQUFpQm9ELE9BQU87Z0JBQUM7WUFDeEMsU0FBVTtnQkFDUjFELElBQUk7b0JBQUVLLFNBQVM7Z0JBQU07WUFDdkI7UUFDRjtRQUVBc0QsVUFBVSxPQUFPQztZQUNmNUQsSUFBSTtnQkFBRUssU0FBUztnQkFBTUMsT0FBTztZQUFLO1lBQ2pDLElBQUk7Z0JBQ0YsTUFBTUUsV0FBVyxNQUFNQyxNQUFNLGNBQWM7b0JBQ3pDb0QsUUFBUTtvQkFDUkMsU0FBUzt3QkFBRSxnQkFBZ0I7b0JBQW1CO29CQUM5Q0MsTUFBTUMsS0FBS0MsU0FBUyxDQUFDTDtnQkFDdkI7Z0JBRUEsSUFBSSxDQUFDcEQsU0FBU0UsRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTTtnQkFDbEMsTUFBTVYsTUFBTU0sVUFBVTtZQUN4QixFQUFFLE9BQU9ELE9BQU87Z0JBQ2ROLElBQUk7b0JBQUVNLE9BQU8sTUFBaUJvRCxPQUFPO2dCQUFDO1lBQ3hDLFNBQVU7Z0JBQ1IxRCxJQUFJO29CQUFFSyxTQUFTO2dCQUFNO1lBQ3ZCO1FBQ0Y7UUFFQTZELGFBQWEsT0FBT2pELElBQUkyQztZQUN0QjVELElBQUk7Z0JBQUVLLFNBQVM7Z0JBQU1DLE9BQU87WUFBSztZQUNqQyxJQUFJO2dCQUNGLGtCQUFrQjtnQkFDbEIsTUFBTTZELFVBQWU7b0JBQUUsR0FBR1AsU0FBUztnQkFBQztnQkFDcEMsSUFBSUEsVUFBVTlCLFlBQVksRUFBRTtvQkFDekJxQyxRQUFRckMsWUFBWSxHQUFHO3dCQUFFLEdBQUc4QixVQUFVOUIsWUFBWTtvQkFBQztnQkFDdEQ7Z0JBQ0EsTUFBTXRCLFdBQVcsTUFBTUMsTUFBTSxjQUFpQixPQUFIUSxLQUFNO29CQUMvQzRDLFFBQVE7b0JBQ1JDLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFtQjtvQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0U7Z0JBQ3ZCO2dCQUVBLElBQUksQ0FBQzNELFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU07Z0JBQ2xDLE1BQU1WLE1BQU1NLFVBQVU7WUFDeEIsRUFBRSxPQUFPRCxPQUFPO2dCQUNkTixJQUFJO29CQUFFTSxPQUFPLE1BQWlCb0QsT0FBTztnQkFBQztZQUN4QyxTQUFVO2dCQUNSMUQsSUFBSTtvQkFBRUssU0FBUztnQkFBTTtZQUN2QjtRQUNGO1FBRUErRCxhQUFhLE9BQU9uRDtZQUNsQmpCLElBQUk7Z0JBQUVLLFNBQVM7Z0JBQU1DLE9BQU87WUFBSztZQUNqQyxJQUFJO2dCQUNELE1BQU1FLFdBQVcsTUFBTUMsTUFBTSxjQUFpQixPQUFIUSxLQUFNO29CQUFFNEMsUUFBUTtnQkFBUztnQkFDcEUsSUFBSSxDQUFDckQsU0FBU0UsRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTTtnQkFDbENYLElBQUlxRSxDQUFBQSxRQUFVO3dCQUFFbkUsT0FBT21FLE1BQU1uRSxLQUFLLENBQUNvRSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUV0RCxFQUFFLEtBQUtBO29CQUFJO1lBQy9ELEVBQUUsT0FBT1gsT0FBTztnQkFDZE4sSUFBSTtvQkFBRU0sT0FBTyxNQUFpQm9ELE9BQU87Z0JBQUM7WUFDeEMsU0FBVTtnQkFDUjFELElBQUk7b0JBQUVLLFNBQVM7Z0JBQU07WUFDdkI7UUFDRjtRQUVBbUUsb0JBQW9CLE9BQU92RCxJQUFJd0Q7WUFDNUIsZ0NBQWdDO1lBQ2hDekUsSUFBSTtnQkFBRUssU0FBUztZQUFLO1lBQ3BCLElBQUk7Z0JBQ0YsTUFBTUksTUFBTSx1QkFBMEIsT0FBSFEsS0FBTTtvQkFDeEM0QyxRQUFRO29CQUNSRSxNQUFNQyxLQUFLQyxTQUFTLENBQUNRO29CQUNyQlgsU0FBUzt3QkFBQyxnQkFBZ0I7b0JBQWtCO2dCQUM3QztnQkFDQSxNQUFNN0QsTUFBTU0sVUFBVTtZQUN4QixFQUFFLE9BQU9tRSxHQUFHO2dCQUNWQyxRQUFRckUsS0FBSyxDQUFDb0U7WUFDaEIsU0FBVTtnQkFDUjFFLElBQUk7b0JBQUVLLFNBQVM7Z0JBQU07WUFDdkI7UUFDSDtRQUVBdUUsY0FBYztZQUNaNUUsSUFBSTtnQkFBRUssU0FBUztnQkFBTUMsT0FBTztZQUFLO1lBQ2pDLElBQUk7Z0JBQ0YsTUFBTUUsV0FBVyxNQUFNQyxNQUFNO2dCQUM3QixJQUFJLENBQUNELFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU07Z0JBQ2xDLE1BQU1DLE9BQU8sTUFBTUosU0FBU0ssSUFBSTtnQkFFaEMsTUFBTWdFLGdCQUFnQmpFLEtBQUtHLEdBQUcsQ0FBQyxDQUFDK0QsSUFBWTt3QkFDMUMsR0FBR0EsQ0FBQzt3QkFDSkMsZ0JBQWdCLElBQUl0RCxLQUFLcUQsRUFBRUMsY0FBYyxFQUFFckQsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7d0JBQ3RFcUQsY0FBYyxJQUFJdkQsS0FBS3FELEVBQUVFLFlBQVksRUFBRXRELFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO3dCQUNsRXNELFNBQVMsSUFBSXhELEtBQUtxRCxFQUFFRyxPQUFPLEVBQUV2RCxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDMUQ7Z0JBRUEzQixJQUFJO29CQUFFSSxnQkFBZ0J5RTtnQkFBYztZQUN0QyxFQUFFLE9BQU92RSxPQUFPO2dCQUNkTixJQUFJO29CQUFFTSxPQUFPLE1BQWlCb0QsT0FBTztnQkFBQztZQUN4QyxTQUFVO2dCQUNSMUQsSUFBSTtvQkFBRUssU0FBUztnQkFBTTtZQUN2QjtRQUNGO1FBRUE2RSxZQUFZLE9BQU9uQyxTQUFTb0MsYUFBYUMsV0FBV0MsU0FBU0M7WUFDM0R0RixJQUFJO2dCQUFFSyxTQUFTO2dCQUFNQyxPQUFPO1lBQUs7WUFDakMsSUFBSTtnQkFDRixNQUFNRSxXQUFXLE1BQU1DLE1BQU0sZ0JBQWdCO29CQUMzQ29ELFFBQVE7b0JBQ1JDLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFtQjtvQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQzt3QkFBRWxCO3dCQUFTb0M7d0JBQWFDO3dCQUFXQzt3QkFBU0M7b0JBQVc7Z0JBQzlFO2dCQUNBLElBQUksQ0FBQzlFLFNBQVNFLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU07Z0JBQ2xDLE1BQU1WLE1BQU0yRSxZQUFZO1lBQzFCLEVBQUUsT0FBT3RFLE9BQU87Z0JBQ2ROLElBQUk7b0JBQUVNLE9BQU8sTUFBaUJvRCxPQUFPO2dCQUFDO2dCQUN0QyxNQUFNcEQ7WUFDUixTQUFVO2dCQUNSTixJQUFJO29CQUFFSyxTQUFTO2dCQUFNO1lBQ3ZCO1FBQ0Y7UUFFQWtGLGlCQUFpQixPQUFPdEUsSUFBSXVFO1lBQzFCeEYsSUFBSTtnQkFBRUssU0FBUztnQkFBTUMsT0FBTztZQUFLO1lBQ2pDLElBQUk7Z0JBQ0YsTUFBTUUsV0FBVyxNQUFNQyxNQUFNLGdCQUFtQixPQUFIUSxLQUFNO29CQUNqRDRDLFFBQVE7b0JBQ1JDLFNBQVM7d0JBQUUsZ0JBQWdCO29CQUFtQjtvQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQzt3QkFBRXBDLFFBQVE7d0JBQVEyRDtvQkFBYztnQkFDdkQ7Z0JBQ0EsSUFBSSxDQUFDaEYsU0FBU0UsRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTTtnQkFDbEMsTUFBTVYsTUFBTTJFLFlBQVk7WUFDMUIsRUFBRSxPQUFPdEUsT0FBTztnQkFDZE4sSUFBSTtvQkFBRU0sT0FBTyxNQUFpQm9ELE9BQU87Z0JBQUM7WUFDeEMsU0FBVTtnQkFDUjFELElBQUk7b0JBQUVLLFNBQVM7Z0JBQU07WUFDdkI7UUFDRjtJQUNGLElBQUkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWt6em0vRG9jdW1lbnRzL0FwcGxpY2F0aW9ucy9BZHZha2thZCBQT1MgQXBwbGljYXRpb24vc3JjL3N0b3Jlcy9zdGFmZlN0b3JlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xuXG50eXBlIFN0YWZmTWVtYmVyID0ge1xuICBpZDogc3RyaW5nO1xuICBlbXBsb3llZUlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgcGhvbmU6IHN0cmluZztcbiAgcG9zaXRpb246IHN0cmluZztcbiAgZGVwYXJ0bWVudDogc3RyaW5nO1xuICBoaXJlRGF0ZTogc3RyaW5nO1xuICBzYWxhcnk6IG51bWJlcjtcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICdpbmFjdGl2ZScgfCAnb24tbGVhdmUnO1xuICBhdmF0YXI/OiBzdHJpbmc7XG4gIGxlYXZlQmFsYW5jZToge1xuICAgIGFubnVhbDogbnVtYmVyO1xuICAgIHNpY2s6IG51bWJlcjtcbiAgICBwZXJzb25hbDogbnVtYmVyO1xuICB9O1xuICBwZXJmb3JtYW5jZToge1xuICAgIHJhdGluZzogbnVtYmVyO1xuICAgIGxhc3RSZXZpZXc6IHN0cmluZztcbiAgfTtcbn07XG5cbnR5cGUgTGVhdmVSZXF1ZXN0ID0ge1xuICBpZDogc3RyaW5nO1xuICBzdGFmZklkOiBzdHJpbmc7XG4gIHN0YWZmTmFtZTogc3RyaW5nO1xuICB0eXBlOiAnYW5udWFsJyB8ICdzaWNrJyB8ICdwZXJzb25hbCcgfCAnZW1lcmdlbmN5JztcbiAgc3RhcnREYXRlOiBzdHJpbmc7XG4gIGVuZERhdGU6IHN0cmluZztcbiAgZGF5czogbnVtYmVyO1xuICByZWFzb246IHN0cmluZztcbiAgc3RhdHVzOiAncGVuZGluZycgfCAnYXBwcm92ZWQnIHwgJ3JlamVjdGVkJztcbiAgYXBwbGllZERhdGU6IHN0cmluZztcbn07XG5cblxuZXhwb3J0IHR5cGUgUGF5cm9sbFJlY29yZCA9IHtcbiAgaWQ6IHN0cmluZztcbiAgc3RhZmZJZDogc3RyaW5nO1xuICBzdGFmZk5hbWU/OiBzdHJpbmc7XG4gIHBheVBlcmlvZFN0YXJ0OiBzdHJpbmc7XG4gIHBheVBlcmlvZEVuZDogc3RyaW5nO1xuICBwYXlEYXRlOiBzdHJpbmc7XG4gIGJhc2ljU2FsYXJ5OiBudW1iZXI7XG4gIGJvbnVzZXM6IG51bWJlcjtcbiAgZGVkdWN0aW9uczogbnVtYmVyO1xuICBuZXRTYWxhcnk6IG51bWJlcjtcbiAgc3RhdHVzOiAncGVuZGluZycgfCAncHJvY2Vzc2VkJyB8ICdwYWlkJztcbiAgcGF5bWVudE1ldGhvZD86IHN0cmluZztcbiAgbm90ZXM/OiBzdHJpbmc7XG59O1xuXG50eXBlIFN0YWZmU3RvcmUgPSB7XG4gIHN0YWZmOiBTdGFmZk1lbWJlcltdO1xuICBsZWF2ZVJlcXVlc3RzOiBMZWF2ZVJlcXVlc3RbXTtcbiAgcGF5cm9sbFJlY29yZHM6IFBheXJvbGxSZWNvcmRbXTtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIGZldGNoU3RhZmY6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGFkZFN0YWZmOiAoc3RhZmY6IE9taXQ8U3RhZmZNZW1iZXIsICdpZCcgfCAnZW1wbG95ZWVJZCcgfCAnc3RhdHVzJyB8ICdsZWF2ZUJhbGFuY2UnIHwgJ3BlcmZvcm1hbmNlJz4pID0+IFByb21pc2U8dm9pZD47XG4gIHVwZGF0ZVN0YWZmOiAoaWQ6IHN0cmluZywgc3RhZmY6IFBhcnRpYWw8U3RhZmZNZW1iZXI+KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkZWxldGVTdGFmZjogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIHVwZGF0ZUxlYXZlUmVxdWVzdDogKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8TGVhdmVSZXF1ZXN0PikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgXG4gIC8vIFBheXJvbGwgQWN0aW9uc1xuICBmZXRjaFBheXJvbGw6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHJ1blBheXJvbGw6IChzdGFmZklkOiBzdHJpbmcsIHBlcmlvZFN0YXJ0OiBzdHJpbmcsIHBlcmlvZEVuZDogc3RyaW5nLCBib251c2VzOiBudW1iZXIsIGRlZHVjdGlvbnM6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbWFya1BheXJvbGxQYWlkOiAoaWQ6IHN0cmluZywgcGF5bWVudE1ldGhvZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZVN0YWZmU3RvcmUgPSBjcmVhdGU8U3RhZmZTdG9yZT4oKHNldCwgZ2V0KSA9PiAoe1xuICBzdGFmZjogW10sXG4gIGxlYXZlUmVxdWVzdHM6IFtdLFxuICBwYXlyb2xsUmVjb3JkczogW10sXG4gIGxvYWRpbmc6IGZhbHNlLFxuICBlcnJvcjogbnVsbCxcblxuICBmZXRjaFN0YWZmOiBhc3luYyAoKSA9PiB7XG4gICAgc2V0KHsgbG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc3RhZmYnKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHN0YWZmJyk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBjb25zdCBtYXBwZWRTdGFmZjogU3RhZmZNZW1iZXJbXSA9IGRhdGEubWFwKChzOiBhbnkpID0+ICh7XG4gICAgICAgIGlkOiBzLmlkLFxuICAgICAgICBlbXBsb3llZUlkOiBzLmVtcGxveWVlSWQsXG4gICAgICAgIG5hbWU6IHMubmFtZSxcbiAgICAgICAgZW1haWw6IHMuZW1haWwsXG4gICAgICAgIHBob25lOiBzLnBob25lLFxuICAgICAgICBwb3NpdGlvbjogcy5wb3NpdGlvbixcbiAgICAgICAgZGVwYXJ0bWVudDogcy5kZXBhcnRtZW50LFxuICAgICAgICBoaXJlRGF0ZTogbmV3IERhdGUocy5oaXJlRGF0ZSkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICBzYWxhcnk6IHMuc2FsYXJ5LFxuICAgICAgICBzdGF0dXM6IHMuc3RhdHVzLFxuICAgICAgICBsZWF2ZUJhbGFuY2U6IHtcbiAgICAgICAgICBhbm51YWw6IHMubGVhdmVCYWxhbmNlQW5udWFsLFxuICAgICAgICAgIHNpY2s6IHMubGVhdmVCYWxhbmNlU2ljayxcbiAgICAgICAgICBwZXJzb25hbDogcy5sZWF2ZUJhbGFuY2VQZXJzb25hbFxuICAgICAgICB9LFxuICAgICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICAgIHJhdGluZzogcy5wZXJmb3JtYW5jZVJhdGluZyxcbiAgICAgICAgICBsYXN0UmV2aWV3OiBzLmxhc3RSZXZpZXcgPyBuZXcgRGF0ZShzLmxhc3RSZXZpZXcpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSA6ICcnXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgLy8gRXh0cmFjdCBsZWF2ZSByZXF1ZXN0c1xuICAgICAgY29uc3QgYWxsTGVhdmVSZXF1ZXN0czogTGVhdmVSZXF1ZXN0W10gPSBbXTtcbiAgICAgIGRhdGEuZm9yRWFjaCgoczogYW55KSA9PiB7XG4gICAgICAgIGlmIChzLmxlYXZlUmVxdWVzdHMgJiYgQXJyYXkuaXNBcnJheShzLmxlYXZlUmVxdWVzdHMpKSB7XG4gICAgICAgICAgcy5sZWF2ZVJlcXVlc3RzLmZvckVhY2goKGxyOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAvLyAuLi4gZXhpc3RpbmcgbWFwcGluZyBsb2dpYyBvciBpbXByb3ZlZFxuICAgICAgICAgICAgIGFsbExlYXZlUmVxdWVzdHMucHVzaCh7XG4gICAgICAgICAgICAgICBpZDogbHIuaWQsXG4gICAgICAgICAgICAgICBzdGFmZklkOiBzLmlkLFxuICAgICAgICAgICAgICAgc3RhZmZOYW1lOiBzLm5hbWUsXG4gICAgICAgICAgICAgICB0eXBlOiBsci50eXBlLFxuICAgICAgICAgICAgICAgc3RhcnREYXRlOiBuZXcgRGF0ZShsci5zdGFydERhdGUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICAgICAgIGVuZERhdGU6IG5ldyBEYXRlKGxyLmVuZERhdGUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICAgICAgIGRheXM6IE1hdGguY2VpbCgobmV3IERhdGUobHIuZW5kRGF0ZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUobHIuc3RhcnREYXRlKS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKSArIDEsXG4gICAgICAgICAgICAgICByZWFzb246IGxyLnJlYXNvbixcbiAgICAgICAgICAgICAgIHN0YXR1czogbHIuc3RhdHVzLFxuICAgICAgICAgICAgICAgYXBwbGllZERhdGU6IG5ldyBEYXRlKGxyLmFwcGxpZWREYXRlKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHNldCh7IHN0YWZmOiBtYXBwZWRTdGFmZiwgbGVhdmVSZXF1ZXN0czogYWxsTGVhdmVSZXF1ZXN0cyB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0KHsgZXJyb3I6IChlcnJvciBhcyBFcnJvcikubWVzc2FnZSB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0KHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgfVxuICB9LFxuXG4gIGFkZFN0YWZmOiBhc3luYyAoc3RhZmZEYXRhKSA9PiB7XG4gICAgc2V0KHsgbG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc3RhZmYnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc3RhZmZEYXRhKSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgc3RhZmYnKTtcbiAgICAgIGF3YWl0IGdldCgpLmZldGNoU3RhZmYoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0KHsgZXJyb3I6IChlcnJvciBhcyBFcnJvcikubWVzc2FnZSB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0KHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZVN0YWZmOiBhc3luYyAoaWQsIHN0YWZmRGF0YSkgPT4ge1xuICAgIHNldCh7IGxvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xuICAgIHRyeSB7XG4gICAgICAvLyBGbGF0dGVuIGZvciBBUElcbiAgICAgIGNvbnN0IHBheWxvYWQ6IGFueSA9IHsgLi4uc3RhZmZEYXRhIH07XG4gICAgICBpZiAoc3RhZmZEYXRhLmxlYXZlQmFsYW5jZSkge1xuICAgICAgICAgcGF5bG9hZC5sZWF2ZUJhbGFuY2UgPSB7IC4uLnN0YWZmRGF0YS5sZWF2ZUJhbGFuY2UgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvc3RhZmYvJHtpZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgc3RhZmYnKTtcbiAgICAgIGF3YWl0IGdldCgpLmZldGNoU3RhZmYoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0KHsgZXJyb3I6IChlcnJvciBhcyBFcnJvcikubWVzc2FnZSB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0KHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZVN0YWZmOiBhc3luYyAoaWQpID0+IHtcbiAgICBzZXQoeyBsb2FkaW5nOiB0cnVlLCBlcnJvcjogbnVsbCB9KTtcbiAgICB0cnkge1xuICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvc3RhZmYvJHtpZH1gLCB7IG1ldGhvZDogJ0RFTEVURScgfSk7XG4gICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIHN0YWZmJyk7XG4gICAgICAgc2V0KHN0YXRlID0+ICh7IHN0YWZmOiBzdGF0ZS5zdGFmZi5maWx0ZXIobSA9PiBtLmlkICE9PSBpZCkgfSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzZXQoeyBlcnJvcjogKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlIH0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXQoeyBsb2FkaW5nOiBmYWxzZSB9KTtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlTGVhdmVSZXF1ZXN0OiBhc3luYyAoaWQsIHVwZGF0ZXMpID0+IHtcbiAgICAgLy8gRXhpc3RpbmcgbG9naWMuLi4ga2VwdCBzaW1wbGVcbiAgICAgc2V0KHsgbG9hZGluZzogdHJ1ZSB9KTtcbiAgICAgdHJ5IHtcbiAgICAgICBhd2FpdCBmZXRjaChgL2FwaS9sZWF2ZS1yZXF1ZXN0cy8ke2lkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlcyksXG4gICAgICAgIGhlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nfVxuICAgICAgIH0pO1xuICAgICAgIGF3YWl0IGdldCgpLmZldGNoU3RhZmYoKTtcbiAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgIH0gZmluYWxseSB7XG4gICAgICAgc2V0KHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgIH1cbiAgfSxcblxuICBmZXRjaFBheXJvbGw6IGFzeW5jICgpID0+IHtcbiAgICBzZXQoeyBsb2FkaW5nOiB0cnVlLCBlcnJvcjogbnVsbCB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9wYXlyb2xsJyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwYXlyb2xsJyk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgXG4gICAgICBjb25zdCBtYXBwZWRQYXlyb2xsID0gZGF0YS5tYXAoKHA6IGFueSkgPT4gKHtcbiAgICAgICAgLi4ucCxcbiAgICAgICAgcGF5UGVyaW9kU3RhcnQ6IG5ldyBEYXRlKHAucGF5UGVyaW9kU3RhcnQpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgcGF5UGVyaW9kRW5kOiBuZXcgRGF0ZShwLnBheVBlcmlvZEVuZCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICBwYXlEYXRlOiBuZXcgRGF0ZShwLnBheURhdGUpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgc2V0KHsgcGF5cm9sbFJlY29yZHM6IG1hcHBlZFBheXJvbGwgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHNldCh7IGVycm9yOiAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldCh7IGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgIH1cbiAgfSxcblxuICBydW5QYXlyb2xsOiBhc3luYyAoc3RhZmZJZCwgcGVyaW9kU3RhcnQsIHBlcmlvZEVuZCwgYm9udXNlcywgZGVkdWN0aW9ucykgPT4ge1xuICAgIHNldCh7IGxvYWRpbmc6IHRydWUsIGVycm9yOiBudWxsIH0pO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3BheXJvbGwnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzdGFmZklkLCBwZXJpb2RTdGFydCwgcGVyaW9kRW5kLCBib251c2VzLCBkZWR1Y3Rpb25zIH0pLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBydW4gcGF5cm9sbCcpO1xuICAgICAgYXdhaXQgZ2V0KCkuZmV0Y2hQYXlyb2xsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHNldCh7IGVycm9yOiAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0KHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgfVxuICB9LFxuXG4gIG1hcmtQYXlyb2xsUGFpZDogYXN5bmMgKGlkLCBwYXltZW50TWV0aG9kKSA9PiB7XG4gICAgc2V0KHsgbG9hZGluZzogdHJ1ZSwgZXJyb3I6IG51bGwgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcGF5cm9sbC8ke2lkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc3RhdHVzOiAncGFpZCcsIHBheW1lbnRNZXRob2QgfSksXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBwYXlyb2xsJyk7XG4gICAgICBhd2FpdCBnZXQoKS5mZXRjaFBheXJvbGwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0KHsgZXJyb3I6IChlcnJvciBhcyBFcnJvcikubWVzc2FnZSB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0KHsgbG9hZGluZzogZmFsc2UgfSk7XG4gICAgfVxuICB9XG59KSk7Il0sIm5hbWVzIjpbImNyZWF0ZSIsInVzZVN0YWZmU3RvcmUiLCJzZXQiLCJnZXQiLCJzdGFmZiIsImxlYXZlUmVxdWVzdHMiLCJwYXlyb2xsUmVjb3JkcyIsImxvYWRpbmciLCJlcnJvciIsImZldGNoU3RhZmYiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsImRhdGEiLCJqc29uIiwibWFwcGVkU3RhZmYiLCJtYXAiLCJzIiwiaWQiLCJlbXBsb3llZUlkIiwibmFtZSIsImVtYWlsIiwicGhvbmUiLCJwb3NpdGlvbiIsImRlcGFydG1lbnQiLCJoaXJlRGF0ZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0Iiwic2FsYXJ5Iiwic3RhdHVzIiwibGVhdmVCYWxhbmNlIiwiYW5udWFsIiwibGVhdmVCYWxhbmNlQW5udWFsIiwic2ljayIsImxlYXZlQmFsYW5jZVNpY2siLCJwZXJzb25hbCIsImxlYXZlQmFsYW5jZVBlcnNvbmFsIiwicGVyZm9ybWFuY2UiLCJyYXRpbmciLCJwZXJmb3JtYW5jZVJhdGluZyIsImxhc3RSZXZpZXciLCJhbGxMZWF2ZVJlcXVlc3RzIiwiZm9yRWFjaCIsIkFycmF5IiwiaXNBcnJheSIsImxyIiwicHVzaCIsInN0YWZmSWQiLCJzdGFmZk5hbWUiLCJ0eXBlIiwic3RhcnREYXRlIiwiZW5kRGF0ZSIsImRheXMiLCJNYXRoIiwiY2VpbCIsImdldFRpbWUiLCJyZWFzb24iLCJhcHBsaWVkRGF0ZSIsIm1lc3NhZ2UiLCJhZGRTdGFmZiIsInN0YWZmRGF0YSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZGF0ZVN0YWZmIiwicGF5bG9hZCIsImRlbGV0ZVN0YWZmIiwic3RhdGUiLCJmaWx0ZXIiLCJtIiwidXBkYXRlTGVhdmVSZXF1ZXN0IiwidXBkYXRlcyIsImUiLCJjb25zb2xlIiwiZmV0Y2hQYXlyb2xsIiwibWFwcGVkUGF5cm9sbCIsInAiLCJwYXlQZXJpb2RTdGFydCIsInBheVBlcmlvZEVuZCIsInBheURhdGUiLCJydW5QYXlyb2xsIiwicGVyaW9kU3RhcnQiLCJwZXJpb2RFbmQiLCJib251c2VzIiwiZGVkdWN0aW9ucyIsIm1hcmtQYXlyb2xsUGFpZCIsInBheW1lbnRNZXRob2QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/stores/staffStore.ts\n"));

/***/ })

});